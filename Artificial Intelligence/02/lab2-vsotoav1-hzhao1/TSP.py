########################################
# CS63: Artificial Intelligence, Lab 2
# Fall 2020, Swarthmore College
########################################

import json
from random import shuffle, sample, randrange
from itertools import combinations
try:
    import matplotlib
    matplotlib.use('Agg')#don't try to create a display window
    from matplotlib import pyplot
    _mpl_available = True
except:
    _mpl_available = False

from Tour import Tour

class TSP:
    """Represents a traveling salesperson problem in two dimensional
    Eculidean space.

    Local search candidates are Tour objects that specify an ordering over
    cities. Neighbors are generated by moving one city to a different spot
    in the ordering. The cost of a tour is the Euclidean distance traveled.

    Local search functions should call the following methods:
    random_candidate() to get an initial state
    get_neighbor() to get a random/best neighbor state
    random_neighbor() to get a random neighbor state
    cost(tour) to determine the total distance covered by a tour
    """
    def __init__(self, filename, select):
        """
        Parameters
        filename: json file with a single dict mapping city names to
                [latitude, longitude] pairs.
        select: "best" or "random". sets self.get_neighbor to return either
                the lowest-cost adjacent tour or a random adjacent tour.

        Class variables
        get_neighbor: method to use for generating neighbors
        locations: a dictionary keyed on cities, where values are a list
        of latitute and longitude
        """
        assert select in ["best", "random"], \
                "unrecognized value for select:" + str(select)
        with open(filename) as f:
            self.locations = json.load(f)
        if select == "best":
            self.get_neighbor = self._best_neighbor
        if select == "random":
            self.get_neighbor = self.random_neighbor

    def distance(self, city1, city2):
        """Euclidian distance in (lat, long) space."""
        lat1,lon1 = self.locations[city1]
        lat2,lon2 = self.locations[city2]
        return ((lat1 - lat2)**2 + (lon1 - lon2)**2)**.5

    def cost(self, tour):
        """Sum of Euclidian distances between adjacent cities in a tour.
        NOTE: This takes linear time. When possible, you should avoid calling
        cost() repeatedly on the same tour. Instead, save the value in a local
        variable and re-use it."""
        c = 0
        for city1, city2 in zip(tour, tour[1:]):
            c += self.distance(city1, city2)
        c += self.distance(tour[-1], tour[0])
        return c

    def random_candidate(self):
        """Generates a random ordering over locations."""
        new_tour = list(self.locations.keys())
        shuffle(new_tour)
        return Tour(new_tour)

    def plot(self, tour, filename):
        """Outputs a matplotlib plot of a tour to the specified filename."""
        assert _mpl_available, "matplotlib.pyplot didn't import correctly"
        longitudes = [self.locations[city][1] for city in tour] +\
                        [self.locations[tour[0]][1]]
        latitudes = [self.locations[city][0] for city in tour] +\
                        [self.locations[tour[0]][0]]
        pyplot.plot(longitudes, latitudes, marker="o")
        pyplot.savefig(filename)

    def _all_neighbors(self, tour):
        """Returns an iterable of all adjacent tours.
        Adjacent tours are those where one city has been moved to a new index,
        but all others are in the same order.
        returns: list (or other iterable) of tours"""
        # moves represents all the different ways to swap between 2 indices in the tour
        moves = combinations(range(len(tour)), 2)
        neighbors = []
        for move in moves:
            neighbors.append(tour.move_city(move[0], move[1]))
        return neighbors

    def _best_neighbor(self, tour):
        """Returns the best adjacent tour and its cost.
        Adjacent tours are those where one city has been moved to a new index,
        but all others are in the same order.
        returns: best_tour, best_cost

        NOTE: Your local search functions should never call this method
              directly. When experimenting with best-neighbor hill climbing,
              you should set the TSP parameter "select" to "best"."""

        #get all neighbors of tour state and append to list
        tours_costs=[]
        neighbors=self._all_neighbors(tour)
        for t in neighbors:
            tours_costs.append((t,self.cost(t)))

        #find best tour and cost in list
        best_tour=tours_costs[0][0]
        best_cost=tours_costs[0][1]
        for tour_cost in tours_costs:
            if tour_cost[1]<best_cost:
                best_tour=tour_cost[0]
                best_cost=tour_cost[1]

        #return best tour and cost
        return best_tour,best_cost

    def random_neighbor(self, tour):
        """Returns a randomly selected adjacent tour and its cost.
        Adjacent tours are those where one city has been moved to a new index,
        but all others are in the same order.
        returns: tour, cost

        NOTE: you should not need to call _all_neighbors() to implement this.
        It can be done much more efficiently!"""

        #use randrange to get start and end index for move_city function
        start=randrange(0,len(tour))
        end=randrange(0,len(tour))
        while start==end: #make sure start and end index are different
            end=randrange(0,len(tour))

        #call move_city with start and end index on tour
        random_tour=tour.move_city(start,end)

        #return random neighbor
        return random_tour,self.cost(random_tour)

if __name__ == '__main__':
    # create a new traveling salesperson problem based on cities in US
    problem = TSP("coordinates/United_States_25.json", "best")

    # each problem maintains a dictionary called locations
    # the keys of locations are city names
    print("\nCities in this problem")
    cities = list(problem.locations.keys())
    print(cities)

    # create a tour from the locations, calculate the cost, and plot it
    tour = problem.random_candidate()
    print("\nRandom tour for this problem\n", tour)
    cost = problem.cost(tour)
    print("\nCost for tour:", cost)
    problem.plot(tour, "tour")

    tour = problem.random_candidate()
    print("\nRandom tour for this problem\n", tour)
    cost = problem.cost(tour)
    print("\nCost for tour:", cost)
    best_tour,best_cost=problem._best_neighbor(tour)
    print(best_tour,best_cost)
    random_tour,random_cost=problem.random_neighbor(tour)
    print(random_tour,random_cost)
