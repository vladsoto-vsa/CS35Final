########################################
# CS63: Artificial Intelligence, Lab 2
# Fall 2020, Swarthmore College
########################################

import json
from random import shuffle, sample, randrange, choice
try:
    import matplotlib
    matplotlib.use('Agg')#don't try to create a display window
    from matplotlib import pyplot
    _mpl_available = True
except:
    _mpl_available = False

from Tour import Tour
from TSP import TSP

class VRP(TSP):
    """Represents a multi-vehicle routing problem in two dimensional
    Eculidean space.

    Local search candidates are lists with length equal to the number
    of vehicles. Each element is a Tour object, and all Tours have the
    same start city. Neighbors are generated by picking a random city
    and assigning it to a random vehicle at a random position in that
    vehicle's tour. You will experiment with different ways of
    defining cost.

    Local search functions should call the following methods:
    random_candidate() to get an initial state
    random_neighbor() to get a random neighbor state
    get_neighbor() an alias for random_neighbor
    cost(plan) an alias for one of the two cost functions you will implement

    NOTE: The distance function is inherited from TSP. You may also find it
          useful to call the TSP cost function, but you can't call it as
          self.cost() because VRP overrides cost(). However, you can call the
          TSP version explicitly with TSP.cost(self, tour).
    """
    def __init__(self, filename, num_vehicles, start_city, cost):
        """
        Parameters
        filename: json file with a single dict mapping city names to
                [latitude, longitude] pairs.
        num_vehicles: How many vehicles the routes will be divided among.
        start_city: Location where all vehicles start and end their tours.
        cost: "max" or "total" sets self.cost to return either the maximum
              length of any vehicle's tour, or the sum of all tour lengths.
        """
        assert cost in ["max", "total"], \
                "unrecognized value for select:" + str(select)
        with open(filename) as f:
            self.locations = json.load(f)
        self.num_vehicles = num_vehicles
        self.start_city = start_city
        self.destinations = list(self.locations)
        if start_city in self.destinations:
            self.destinations.remove(start_city)
        else:
            print("Warning: start city", start_city, "not found.")
            self.start_city = self.destinations.pop()
            print("Starting from", self.start_city, "instead.")
        if cost == "max":
            self.cost = self._max_cost
        if cost == "total":
            self.cost = self._total_cost

    def _max_cost(self, plan):
        """Evaluates the cost of each vehicle's tour in the plan and returns
        the max over those vehicle costs."""

        #initialize variable to be returned
        max_cost=0

        #find cost of each tour, store max in max_cost
        for t in plan:
            c=TSP.cost(self,t)
            if c>max_cost:
                max_cost=c

        #return max_cost
        return max_cost

    def _total_cost(self, plan):
        """Evaluates the cost of each vehicle's tour in the plan and returns
        the sum over those vehicle costs."""

        #initialize incrementer
        total=0

        #find cost of each tour, append it to total
        for t in plan:
            c=TSP.cost(self,t)
            total+=c

        #return total
        return total

    def random_candidate(self):
        """Generates a random assignment and ordering of cities for each
        vehicle and returns that plan and its cost."""
        shuffle(self.destinations)
        ranges = [0] + sorted(sample(range(len(self.destinations)), \
                              self.num_vehicles-1)) + [len(self.destinations)]
        plan = []
        for i in range(self.num_vehicles):
            t = Tour([self.start_city] + self.destinations[ranges[i]:ranges[i+1]])
            plan.append(t)
        return plan

    def plot(self, plan, filename):
        """Outputs a matplotlib plot of a plan to the specified filename."""
        assert _mpl_available, "matplotlib.pyplot didn't import correctly"
        for tour in plan:
            longitudes = [self.locations[city][1] for city in tour] +\
                            [self.locations[tour[0]][1]]
            latitudes = [self.locations[city][0] for city in tour] +\
                            [self.locations[tour[0]][0]]
            pyplot.plot(longitudes, latitudes, marker="o")
        pyplot.savefig(filename)

    def random_neighbor(self, plan):
        """Generates a random neighboring plan."""
        plan = [Tour(t) for t in plan]
        city = choice(self.destinations)
        vehicle = randrange(self.num_vehicles)
        for i in range(len(plan)):
            if city in plan[i]:
                plan[i] = plan[i].remove_city(city)
                break
        insert_index = randrange(1,len(plan[vehicle])+1)
        plan[vehicle] = plan[vehicle].add_city(city, insert_index)
        return plan, self.cost(plan)

    def all_neighbors(self, plan):
        raise NotImplementedError("This would be very inefficient.")

    get_neighbor = random_neighbor

if __name__ == '__main__':
    problem = VRP("coordinates/United_States_25.json", 2, "St. Louis", "total")
    plan = problem.random_candidate()
    for i in range(len(plan)):
        print("Tour", i)
        print(plan[i])
    problem.plot(plan, "plan")
    print(problem._max_cost(plan))
    print(problem._total_cost(plan))
